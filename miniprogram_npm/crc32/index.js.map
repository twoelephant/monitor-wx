{"version":3,"sources":["crc32.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function () {\r\n\t\r\n\r\n\tvar table = [],\r\n\t\tpoly = 0xEDB88320; // reverse polynomial\r\n\r\n\t// build the table\r\n\tfunction makeTable() {\r\n\t\tvar c, n, k;\r\n\r\n\t\tfor (n = 0; n < 256; n += 1) {\r\n\t\t\tc = n;\r\n\t\t\tfor (k = 0; k < 8; k += 1) {\r\n\t\t\t\tif (c & 1) {\r\n\t\t\t\t\tc = poly ^ (c >>> 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tc = c >>> 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttable[n] = c >>> 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction strToArr(str) {\r\n\t\t// sweet hack to turn string into a 'byte' array\r\n\t\treturn Array.prototype.map.call(str, function (c) {\r\n\t\t\treturn c.charCodeAt(0);\r\n\t\t});\r\n\t}\r\n\r\n\t/*\r\n\t * Compute CRC of array directly.\r\n\t *\r\n\t * This is slower for repeated calls, so append mode is not supported.\r\n\t */\r\n\tfunction crcDirect(arr) {\r\n\t\tvar crc = -1, // initial contents of LFBSR\r\n\t\t\ti, j, l, temp;\r\n\r\n\t\tfor (i = 0, l = arr.length; i < l; i += 1) {\r\n\t\t\ttemp = (crc ^ arr[i]) & 0xff;\r\n\r\n\t\t\t// read 8 bits one at a time\r\n\t\t\tfor (j = 0; j < 8; j += 1) {\r\n\t\t\t\tif ((temp & 1) === 1) {\r\n\t\t\t\t\ttemp = (temp >>> 1) ^ poly;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttemp = (temp >>> 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcrc = (crc >>> 8) ^ temp;\r\n\t\t}\r\n\r\n\t\t// flip bits\r\n\t\treturn crc ^ -1;\r\n\t}\r\n\r\n\t/*\r\n\t * Compute CRC with the help of a pre-calculated table.\r\n\t *\r\n\t * This supports append mode, if the second parameter is set.\r\n\t */\r\n\tfunction crcTable(arr, append) {\r\n\t\tvar crc, i, l;\r\n\r\n\t\t// if we're in append mode, don't reset crc\r\n\t\t// if arr is null or undefined, reset table and return\r\n\t\tif (typeof crcTable.crc === 'undefined' || !append || !arr) {\r\n\t\t\tcrcTable.crc = 0 ^ -1;\r\n\r\n\t\t\tif (!arr) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// store in temp variable for minor speed gain\r\n\t\tcrc = crcTable.crc;\r\n\r\n\t\tfor (i = 0, l = arr.length; i < l; i += 1) {\r\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ arr[i]) & 0xff];\r\n\t\t}\r\n\r\n\t\tcrcTable.crc = crc;\r\n\r\n\t\treturn crc ^ -1;\r\n\t}\r\n\r\n\t// build the table\r\n\t// this isn't that costly, and most uses will be for table assisted mode\r\n\tmakeTable();\r\n\r\n\tmodule.exports = function (val, direct) {\r\n\t\tvar val = (typeof val === 'string') ? strToArr(val) : val,\r\n\t\t\tret = direct ? crcDirect(val) : crcTable(val);\r\n\r\n\t\t// convert to 2's complement hex\r\n\t\treturn (ret >>> 0).toString(16);\r\n\t};\r\n\tmodule.exports.direct = crcDirect;\r\n\tmodule.exports.table = crcTable;\r\n}());\r\n"]}