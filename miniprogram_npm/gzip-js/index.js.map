{"version":3,"sources":["gzip.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function () {\r\n\t\r\n\r\n\tvar crc32 = require('crc32'),\r\n\t\tdeflate = require('deflate-js'),\r\n\t\t// magic numbers marking this file as GZIP\r\n\t\tID1 = 0x1F,\r\n\t\tID2 = 0x8B,\r\n\t\tcompressionMethods = {\r\n\t\t\t'deflate': 8\r\n\t\t},\r\n\t\tpossibleFlags = {\r\n\t\t\t'FTEXT': 0x01,\r\n\t\t\t'FHCRC': 0x02,\r\n\t\t\t'FEXTRA': 0x04,\r\n\t\t\t'FNAME': 0x08,\r\n\t\t\t'FCOMMENT': 0x10\r\n\t\t},\r\n\t\tosMap = {\r\n\t\t\t'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS\r\n\t\t\t'amiga': 1, // Amiga\r\n\t\t\t'vmz': 2, // VMS (VAX or Alpha AXP)\r\n\t\t\t'unix': 3, // Unix\r\n\t\t\t'vm/cms': 4, // VM/CMS\r\n\t\t\t'atari': 5, // Atari\r\n\t\t\t'hpfs': 6, // HPFS file system (OS/2, NT 3.x)\r\n\t\t\t'macintosh': 7, // Macintosh\r\n\t\t\t'z-system': 8, // Z-System\r\n\t\t\t'cplm': 9, // CP/M\r\n\t\t\t'tops-20': 10, // TOPS-20\r\n\t\t\t'ntfs': 11, // NTFS file system (NT)\r\n\t\t\t'qdos': 12, // SMS/QDOS\r\n\t\t\t'acorn': 13, // Acorn RISC OS\r\n\t\t\t'vfat': 14, // VFAT file system (Win95, NT)\r\n\t\t\t'vms': 15, // MVS (code also taken for PRIMOS)\r\n\t\t\t'beos': 16, // BeOS (BeBox or PowerMac)\r\n\t\t\t'tandem': 17, // Tandem/NSK\r\n\t\t\t'theos': 18 // THEOS\r\n\t\t},\r\n\t\tos = 'unix',\r\n\t\tDEFAULT_LEVEL = 6;\r\n\r\n\tfunction putByte(n, arr) {\r\n\t\tarr.push(n & 0xFF);\r\n\t}\r\n\r\n\t// LSB first\r\n\tfunction putShort(n, arr) {\r\n\t\tarr.push(n & 0xFF);\r\n\t\tarr.push(n >>> 8);\r\n\t}\r\n\r\n\t// LSB first\r\n\tfunction putLong(n, arr) {\r\n\t\tputShort(n & 0xffff, arr);\r\n\t\tputShort(n >>> 16, arr);\r\n\t}\r\n\r\n\tfunction putString(s, arr) {\r\n\t\tvar i, len = s.length;\r\n\t\tfor (i = 0; i < len; i += 1) {\r\n\t\t\tputByte(s.charCodeAt(i), arr);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readByte(arr) {\r\n\t\treturn arr.shift();\r\n\t}\r\n\r\n\tfunction readShort(arr) {\r\n\t\treturn arr.shift() | (arr.shift() << 8);\r\n\t}\r\n\r\n\tfunction readLong(arr) {\r\n\t\tvar n1 = readShort(arr),\r\n\t\t\tn2 = readShort(arr);\r\n\r\n\t\t// JavaScript can't handle bits in the position 32\r\n\t\t// we'll emulate this by removing the left-most bit (if it exists)\r\n\t\t// and add it back in via multiplication, which does work\r\n\t\tif (n2 > 32768) {\r\n\t\t\tn2 -= 32768;\r\n\r\n\t\t\treturn ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);\r\n\t\t}\r\n\r\n\t\treturn (n2 << 16) | n1;\r\n\t}\r\n\r\n\tfunction readString(arr) {\r\n\t\tvar charArr = [];\r\n\r\n\t\t// turn all bytes into chars until the terminating null\r\n\t\twhile (arr[0] !== 0) {\r\n\t\t\tcharArr.push(String.fromCharCode(arr.shift()));\r\n\t\t}\r\n\r\n\t\t// throw away terminating null\r\n\t\tarr.shift();\r\n\r\n\t\t// join all characters into a cohesive string\r\n\t\treturn charArr.join('');\r\n\t}\r\n\r\n\t/*\r\n\t * Reads n number of bytes and return as an array.\r\n\t *\r\n\t * @param arr- Array of bytes to read from\r\n\t * @param n- Number of bytes to read\r\n\t */\r\n\tfunction readBytes(arr, n) {\r\n\t\tvar i, ret = [];\r\n\t\tfor (i = 0; i < n; i += 1) {\r\n\t\t\tret.push(arr.shift());\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/*\r\n\t * ZIPs a file in GZIP format. The format is as given by the spec, found at:\r\n\t * http://www.gzip.org/zlib/rfc-gzip.html\r\n\t *\r\n\t * Omitted parts in this implementation:\r\n\t */\r\n\tfunction zip(data, options) {\r\n\t\tvar flags = 0,\r\n\t\t\tlevel,\r\n\t\t\tcrc, out = [];\r\n\r\n\t\tif (!options) {\r\n\t\t\toptions = {};\r\n\t\t}\r\n\t\tlevel = options.level || DEFAULT_LEVEL;\r\n\r\n\t\tif (typeof data === 'string') {\r\n\t\t\tdata = Array.prototype.map.call(data, function (char) {\r\n\t\t\t\treturn char.charCodeAt(0);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// magic number marking this file as GZIP\r\n\t\tputByte(ID1, out);\r\n\t\tputByte(ID2, out);\r\n\r\n\t\tputByte(compressionMethods['deflate'], out);\r\n\r\n\t\tif (options.name) {\r\n\t\t\tflags |= possibleFlags['FNAME'];\r\n\t\t}\r\n\r\n\t\tputByte(flags, out);\r\n\t\tputLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);\r\n\r\n\t\t// put deflate args (extra flags)\r\n\t\tif (level === 1) {\r\n\t\t\t// fastest algorithm\r\n\t\t\tputByte(4, out);\r\n\t\t} else if (level === 9) {\r\n\t\t\t// maximum compression (fastest algorithm)\r\n\t\t\tputByte(2, out);\r\n\t\t} else {\r\n\t\t\tputByte(0, out);\r\n\t\t}\r\n\r\n\t\t// OS identifier\r\n\t\tputByte(osMap[os], out);\r\n\r\n\t\tif (options.name) {\r\n\t\t\t// ignore the directory part\r\n\t\t\tputString(options.name.substring(options.name.lastIndexOf('/') + 1), out);\r\n\r\n\t\t\t// terminating null\r\n\t\t\tputByte(0, out);\r\n\t\t}\r\n\r\n\t\tdeflate.deflate(data, level).forEach(function (byte) {\r\n\t\t\tputByte(byte, out);\r\n\t\t});\r\n\r\n\t\tputLong(parseInt(crc32(data), 16), out);\r\n\t\tputLong(data.length, out);\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction unzip(data, options) {\r\n\t\t// start with a copy of the array\r\n\t\tvar arr = Array.prototype.slice.call(data, 0),\r\n\t\t\tt,\r\n\t\t\tcompressionMethod,\r\n\t\t\tflags,\r\n\t\t\tmtime,\r\n\t\t\txFlags,\r\n\t\t\tkey,\r\n\t\t\tos,\r\n\t\t\tcrc,\r\n\t\t\tsize,\r\n\t\t\tres;\r\n\r\n\t\t// check the first two bytes for the magic numbers\r\n\t\tif (readByte(arr) !== ID1 || readByte(arr) !== ID2) {\r\n\t\t\tthrow 'Not a GZIP file';\r\n\t\t}\r\n\r\n\t\tt = readByte(arr);\r\n\t\tt = Object.keys(compressionMethods).some(function (key) {\r\n\t\t\tcompressionMethod = key;\r\n\t\t\treturn compressionMethods[key] === t;\r\n\t\t});\r\n\r\n\t\tif (!t) {\r\n\t\t\tthrow 'Unsupported compression method';\r\n\t\t}\r\n\r\n\t\tflags = readByte(arr);\r\n\t\tmtime = readLong(arr);\r\n\t\txFlags = readByte(arr);\r\n\t\tt = readByte(arr);\r\n\t\tObject.keys(osMap).some(function (key) {\r\n\t\t\tif (osMap[key] === t) {\r\n\t\t\t\tos = key;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// just throw away the bytes for now\r\n\t\tif (flags & possibleFlags['FEXTRA']) {\r\n\t\t\tt = readShort(arr);\r\n\t\t\treadBytes(arr, t);\r\n\t\t}\r\n\r\n\t\t// just throw away for now\r\n\t\tif (flags & possibleFlags['FNAME']) {\r\n\t\t\treadString(arr);\r\n\t\t}\r\n\r\n\t\t// just throw away for now\r\n\t\tif (flags & possibleFlags['FCOMMENT']) {\r\n\t\t\treadString(arr);\r\n\t\t}\r\n\r\n\t\t// just throw away for now\r\n\t\tif (flags & possibleFlags['FHCRC']) {\r\n\t\t\treadShort(arr);\r\n\t\t}\r\n\r\n\t\tif (compressionMethod === 'deflate') {\r\n\t\t\t// give deflate everything but the last 8 bytes\r\n\t\t\t// the last 8 bytes are for the CRC32 checksum and filesize\r\n\t\t\tres = deflate.inflate(arr.splice(0, arr.length - 8));\r\n\t\t}\r\n\r\n\t\tif (flags & possibleFlags['FTEXT']) {\r\n\t\t\tres = Array.prototype.map.call(res, function (byte) {\r\n\t\t\t\treturn String.fromCharCode(byte);\r\n\t\t\t}).join('');\r\n\t\t}\r\n\r\n\t\tcrc = readLong(arr);\r\n\t\tif (crc !== parseInt(crc32(res), 16)) {\r\n\t\t\tthrow 'Checksum does not match';\r\n\t\t}\r\n\r\n\t\tsize = readLong(arr);\r\n\t\tif (size !== res.length) {\r\n\t\t\tthrow 'Size of decompressed file not correct';\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\tmodule.exports = {\r\n\t\tzip: zip,\r\n\t\tunzip: unzip,\r\n\t\tget DEFAULT_LEVEL() {\r\n\t\t\treturn DEFAULT_LEVEL;\r\n\t\t}\r\n\t};\r\n}());\r\n"]}